# 0.网络有用资料

链接：https://www.anquanke.com/post/id/258874
链接：https://space.bilibili.com/476114390/search/video?keyword=Linux

# 1.第一个驱动程序

## 驱动的简易流程
    
- 1.确定major，0表示自动分配
- 2.实例化一个file_operations结构体
- 3.实现open/write/read等函数，链接到以上结构体
- 4.在(__init修饰)入口函数内注册字符设备register_chrdev，
    例如 register_chrdev(0, "hello", &hello_ops); 完成注册后将在/prop/devices看到字符设备/hello
    被__init修饰的入口函数代码会存入.init.text段，
    表示该代码仅仅在初始化期间使用，在模块装载后，该代码内存将被释放
- 5.在(__exit修饰)出口函数内注销字符设备unregister_chrdev，
    被__exit修饰的出口函数代码会存入.exit.text段，
- 6.添加module_init、modile_exit
    例：在module_init(hello_init)和module_exit(hello_exit)中，
    如果定义了MODULE，相当于静态加载进内核，
    相当于定义一个存放在.initcall6.init代码段的_initcall_hello_init6的函数指针变量，并指向hello_init
    linux在do_initcalls函数中遍历initcalls段中每一个函数指针，然后顺序执行函数
    没有定义MODULE，相当于动态加载进内核，
    会生成 文件名.ko 文件 ，通过insmod加载进入内核，通过rmmod卸载
    可以不使用module_init和module_exit宏，而是直接定义init_moudle和cleanup_module
    -   https://blog.csdn.net/OnlyLove_/article/details/121641335
- 7.添加其他信息 MODULE_LICENSE("GPL");MODULE_AUTHOR("");MODULE_DESCRIPTION("");

## 驱动程序的udev

- 1.实例化一个class结构体
- 2.
    6.实例化一个class结构体
    7.在入口函数中创建类class_create，然后紧接着创建设备节点device_create
    8.在出口函数中销毁设备节点device_destroy，然后紧接着销毁类class_destroy,最后才是销毁字符设备
 
----------
`asfd`

----------

----------

**asd**

- 1
  - 1.1
  - 1.2
  - 1.3




    